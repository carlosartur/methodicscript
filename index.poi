###
Comentários de múltiplas linhas, documentações
###
#comentários de linhas simples

class Living:
    abstract

class Animal:
    #sempre primeira linha não comentário, se não hover, vai extender classe object
    extends Living

    ###
    traits: não existem traits em si, aqui devem ser usadas classes que serão usadas como se fossem traits. 
    A ordem de chamada é a ordem de importancia, ou seja, se "Planets" tiver um método com o nome igual a "Kinds", 
    esse será desconsiderado em favor do método de "Kinds", porque "Kinds" foi chamada primeiro. Caso o método exista na própria classe,
    ele não será sobrescrito por trait.
    ###
    traits Kinds, Planets, Live  
    
    ###
    atributos públicos: internamente a única diferença entre os atributos públicos e privados é que
    atributos públicos a linguagem gera um getter e um setter padrão,
    e atributo privado, o getter e o setter tem que ser gerados manualmente, como no exemplo abaixo.
    o transpiler vai sempre renomear todos os atributos como "__nome_do_atributo"
    constantes devem ser sempre publicas, e a única diferença para outras variáveis é que o seu setter dispara um erro.
    ###
    public:        
        #getters e setters
        attr name:
            get: method 
                return this.name
            set: method(value) 
                this.name = value
        
        #valor padrão
        attr height = 125 

        #valor padrão, getters e setters
        attr color = "brown":
            get: method 
                return this.color
            set: method(value) 
                this.color = value

        #construtor padrão, se não for setado, será assim: os parametros serão recebidos em ordem que aparecem na classe, e serão setados conforme passados
        method constructor(name, height, color, foot_number, size):
            this.setParamsAsAttrs(name, height, color, foot_number, size)
            super.constructor()

        #se não houver um return, é a mesma coisa que "return this". se não tiver parametro nenhum, parenteses são opcionais
        method bla:
            print(this.name)
        
        #valor padrão de parametro
        method blaWorldDefaultParams(worldILive = "Earth"):
            #interpolação de strings, valores com ${valor} e métodos ou códigos com ${código}
            print(`Hello, ${worldILive}, I am ${this.name}`)
            print(`${ 2 + 2 }`)
            return true
        
        method blaWorld2(worldILive, worldYouLive):
            print(`Hello, ${worldILive}, I am ${this.name}`)
            return true
    private:
        attr foot_number:
            get: method 
                return this.foot_number / 2
            set: method(value) 
                this.foot_number * 2
        
        #totalmente privado, só acessível pelo próprio objeto
        attr size 
        
        method privateMethod(worldILive, worldYouLive):
            print(`Hello, ${worldILive}, I am ${this.name}`)
            return true
        
    static:
        const KINGDOM = "Animalia"
        #static methods returns null if there's not a return statement
        method staticMethod():
            return true


#fora da classe, algumas coisas mudam
var x = new Animal('Rex', 120, 'brown', 4, 150)
#tipos primitivos, apenas booleanos, numeros e strings
var y = 123.123, z = 'Abc', a = false

#instruções de mais de uma linha seguem forma do javascript
y = 
    new Animal('Rex', 120, 'brown', 4, 150)

#if e else
if 1 == 2:
    print(1)
elseif 100 > 200:
    print(2)
elseunless 1000 < 2000:
    print(4)
else:
    print(3)

unless 1 == 2:
    print('oi')

#switch - não usar break, não é necessário.
switch value:
    case 1:
        print('is 1')
    case 2:
        print('is 2')
    default:
        print('is another')

###
laços de repetição
###
#for classico
from index = 0 to 100 step 2:
    print(index)

#foreach & arrays & dictionaries
list = [1, 2, 3, 4]
dict = [
    abc = 'abc',
    123 = '123',
]

for index in list as val:
    print(`${val} is position ${index} in list`)

for index in dict as val:
    print(`${val} is position ${index} in dict`)

#while
while cond:
    print('oi')

#do while
repeat:
    print('oi')
while cond

#functions fora das classes, se não tiver return, retornará null
function test(fistProp, secondProp = false):
    return firstProp * secondProp